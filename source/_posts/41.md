---
layout: leetcode
title: leetcode 41 - First Missing Positive
categories:
  - study
tags:
  - algorithms
  - interview_2019
date: 2019-04-21 21:01:18
---
### [41\. First Missing Positive](https://leetcode.com/problems/first-missing-positive/)

Difficulty: **Hard**


Given an unsorted integer array, find the smallest missing positive integer.

**Example 1:**

```
Input: [1,2,0]
Output: 3
```

**Example 2:**

```
Input: [3,4,-1,1]
Output: 2
```

**Example 3:**

```
Input: [7,8,9,11,12]
Output: 1
```

**Note:**

Your algorithm should run in _O_(_n_) time and uses constant extra space.


#### Solution

Language: **Java**

```java
​
// 思路原型， 用boolean array用true和false标记的找到或者没找到
// 由于题目要求用N(1) space, 所以可以把原数组反向成负数来做boolean标记•
public class Solution {
    //[3,-1,2,0,-2,5,1]
    public static int firstMissingPositive(int[] nums) {
​
        if(nums==null || nums.length ==0)   return 1;
       //先把负数和0没用，变成MAX. 之后可以用负数标记已经找到的数
        //[3,max,2,max,max,5,1]
       for(int i=0; i<nums.length; i++){
           if(nums[i]<=0){
               nums[i] = Integer.MAX_VALUE;
           }
       }
       //例遍数组，把数值对应的数组位置标记成负数（找到了）
       //[3,max,-2,max,max,5,1]     -->i = 0
       //[3,max,-2,max,max,5,1]     -->i = 1
       //[3,-max,-2,max,max,5,1]    -->i = 2
       //[3,-max,-2,max,max,5,1]    -->i = 3
       //[3,-max,-2,max,max,5,1]    -->i = 4
       //[3,-max,-2,max,-max,5,1]   -->i = 5
       //[-3,-max,-2,max,-max,5,1]  -->i = 6
        for(int i=0; i<nums.length; i++){
            int num = Math.abs(nums[i]);
           if(num<=nums.length) {
               nums[num-1] = -Math.abs(nums[num-1]);
           }
//            System.out.println(Arrays.toString(nums));
       }
        for(int i=0; i<nums.length; i++){
            if(nums[i]>0)
                return i + 1;
        }
​
        return nums.length+1;
    }
}
​
```