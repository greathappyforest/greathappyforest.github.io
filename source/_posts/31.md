---
layout: leetcode
title: leetcode 31 - Next Permutation
categories:
  - study
tags:
  - algorithms
  - interview_2019
date: 2019-04-21 20:57:36
---

### [31\. Next Permutation](https://leetcode.com/problems/next-permutation/)

Difficulty: **Medium**


Implement **next permutation**, which rearranges numbers into the lexicographically next greater permutation of numbers.

If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).

The replacement must be and use only constant extra memory.

Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.

`1,2,3` → `1,3,2`  
`3,2,1` → `1,2,3`  
`1,1,5` → `1,5,1`


#### Solution

Language: **Java**

```java
// 1. 从低位向高位（从右向左）找第一个递减的数：s[i]<s[i+1]。如果不存在，则表明该permutation已经最大，next permutation为当前序列的逆序。
// 2. 在s[i+1:n-1]中找一个j，使s[j]>s[i]>=s[j+1]，swap(s[i], s[j])
// 3. 将s[i+1:n-1]排序，从低位到高位单调递减。
​
class Solution {
    public void nextPermutation(int[] nums) {
      //from right to left, if keep increase, i--
        int i = nums.length-2;
        while(i>=0 && nums[i+1]<=nums[i]){
            i--;
        }
        if(i>=0){
            int j = nums.length-1;
            while(j>=0 && nums[j]<=nums[i]){
                j--;
            }
            swap(nums,i,j);
        }
        reserseSubArr(nums,i+1);
​
    }
    
     public void swap(int[] nums, int i, int j ){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
​
    public void reserseSubArr(int[] nums, int startIndex){
        int i = startIndex, j = nums.length-1;
        while(i<j){
            swap(nums, i, j);
            i++;
            j--;
        }
    }
}
```